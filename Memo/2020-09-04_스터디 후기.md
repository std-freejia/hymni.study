### 2020-09-04 스터디 후기 

참석자 : 동혁 일비 지아 (진영 개인사정으로 불참)

작성자 : 지아 

----------

</br>

- 두 번째 비대면 스터디...! (16:00 ~ 17:40)

  

- 체감 난이도 공유 

  - 지아  " 어렵지만 적응되가고 있는 것 같다 "

  - 동혁 " 알고리즘은 꾸준히하는게 중요한거 같다. 저번주보다 덜 답답하고 어떻게 해야할지 느껴지기 시작한다. "

  - 일비  " 좀 익숙해지고 있어서 저번주 보다 나은 것 같다 "

  - 시간 안에 설계가 안되면, 바로 중단하고(더 붙잡고 있으면 스트레스 받음.) 해설 찾아서 구조 감 잡으면서 풀어봅시다. 

    </br>

- 테트로미노

  - 문제는 어렵지 않게 느껴졌지만, 19가지 경우에 대한 인덱스 실수를 피하느라 셋 다 금방 풀지 못했다.  

  - 지아 - 세로2 가로3/ 세로3 가로2 확보가 되는지 먼저 체크. 6개 합 구한 후 2칸을 빼는 방식.

  - 일비 - 시작점을 순회하면서 cal 함수로 처리. 시작점 정하는 반복문 코드와 계산 함수를 나눠놓음.

  - 동혁 - 19가지 경우를 19개 if 문으로 처리. 세로2 가로3/ 세로3 가로2 if문 처리를 줄일 수 있다는 리뷰.

    

- 퇴사 

  - 지아 - 오늘 상담을 한다/안한다 재귀호출 2번으로 구현. 

  - 일비 - 날짜 크기만큼의 배열을 써서 일을 하는날/안 하는날 표시. 매일 매일을 확인하는 방식. 벡터 활용 좋아하고 잘함. 

  - 동혁 - 재귀함수 인자를 줄이려고 노력. for문 내부에서 일할 날짜를 더해주면서, N보다 일해야할 날이 많아지면 continue 처리. 재귀는 1번만 호출.

    

- 부분수열의 합

  - 지아 - 주어진 수열만큼 전부 방문해보는 완전탐색으로 풀었음. 해당 위치의 숫자를 부분집합에 포함시킨다/안시킨다를 재귀호출 2번으로 구현. 

    다음에는 [비트마스크로 구현](https://woongsin94.tistory.com/157) 하겠음.

  - 일비 - 이 숫자를 선택 한다/안한다 재귀호출 2번으로 구현. 

    

- 차이를 최대로 

  - 지아 - C++ STL next_permutation() 활용 

    혼자 1시간 초과해서도 틀리니까 문제 해설 찾아봄

    왜 '모든 순열'을 구하려면 주어진 수열을 sort() 후에 do-while 로 next_permutation() 해야 하는지 이해가 안되서 [질문게시판에 글올리고](https://www.acmicpc.net/board/view/56311) 댓글로 혼나고 배움

  - 일비 - original array(주어진 수열)에서 숫자를 하나씩 뽑아서 target array에 추가하고 합을 계산함

    백트래킹 방식을 선호함 

    

- next_permutation()  algorithm 헤더에 있음

  이 함수는 주어진 수열의 다음순열이 없으면 false 를 반환해줌. '다음' 순열의 기준은 현재 순열보다 내림차순된 순열이 있느냐/없느냐다.

  예를 들어, 1234 의 다음 순열은 1243

  1234  -> 1243 -> 1324 -> 1342  ... -> 4321  이처럼 첫 수열은 오름차순이고 맨 마지막 수열은 내림차순임을 이용하여 구현된 함수.  

  따라서 처음에 next_permutation  에 4321 을 넣고 실행하면, 이미 전부 내림차순이므로(다음순열이 없다고 판단) false 반환하고 종료.

  </br>

- 9월 11일 금요일 16시에 만나요:)  출제자는 지아

----

</br>