## 메모리 - 운영체제 

---------

목차 Content

1. 메인 메모리 개요

2. 주소 변환을 수행하는 MMU 기법 (MMU scheme)

3. 메모리 관리에 필요한 개념

   * 동적로딩
   * 동적연결
   * 중첩
   * 스와핑

4. 물리적 메모리의 할당 방식 

   1) 연속할당 방식

   ​	고정분할 방식 

   ​	가변분할 방식

   2) 불연속 할당방식 

5. 페이징 기법

6. 세그먼테이션

7. 페이지드 세그먼테이션 

</br>

-------------

</br>

## 1.메인 메모리 개요 

 컴퓨터는 byte 단위로 메모리 주소를 부여한다. 

32bit 주소체계에서는 2^32 byte 만큼의 서로 다른 주소를 할당할 수 있다. 

우편 주소가 '서울시 양천구 신정동 .. ' 이런 식으로 행정구역을 기준으로 나뉘는 것처럼, 컴퓨터의 메모리 주소도 32bit의 일련의 영역을 나누어 관리한다. 

컴퓨터가 메모리를 어떻게 나누어 관리하는지, 프로그램이 물리적 메모리에 어떻게 올라가서 주소를 할당받는지 살펴보자. 

</br>

* ### 주소 바인딩 

  * 프로그램이 실행을 위해 메모리에 적재되면, 그 프로세스를 위한 독자적인 주소 공간이 생긴다. 이를 논리적 주소(가상 주소)라고 한다. 

    반면, 물리적주소는 물리 메모리에 실제로 존재하는 위치(주소)다. 

  * CPU는 프로세스 마다의 논리적 주소를 기반으로 명령을 수행한다. 

    CPU는 논리적 주소가 물리 메모리의 어느 위치에 실제 매핑되는지 확인해야 한다. 이를 주소바인딩이라고 한다. 

  </br>

* ### 주소 바인딩의 방식 

  프로그램이 적재되는 '**물리적 메모리의 주소가 결정되는 시점**' 에 따라 3가지 방식이 있다.

  * **컴파일 타임** 바인딩 
    * 물리 메모리 주소가 프로그램을 컴파일할 때 결정되는 주소 바인딩 방식.
    * 물리 메모리 위치 변경을 위해서는 재컴파일 해야하므로 현대의 시분할 컴퓨팅 환경에서 적절치 않아 거의 사용하지 않는다. 
  * **로드 타임** 바인딩 
    * 프로그램 실행이 시작될 때 물리적 메모리 주소가 결정된다. 
    * **로더**(loader)의 책임 하에 메모리 주소가 정해진다. 
  * **실행 타임**(런타임) 바인딩 (execute time binding, run time binding)
    * 실행 중에도 물리 메모리의 주소가 변경될 수 있다. 
    * CPU가 논리 주소를 참조할 때 마다 **주소 매핑 테이블**을 이용해 바인딩을 점검해야 한다.
    * MMU, 기준 레지스터(base register), 한계 레지스터(limit register) 라는 하드웨어적 자원을 기반으로 한다.  

  </br></br>

  

## 2.  주소 변환을 수행하는 MMU scheme 

CPU가 특정 프로세스의 논리 주소를 참조하려고 한다. 

이 때, MMU는 논리 주소에 기준 레지스터 값을 더해서 물리 주소를 얻는다. 

* **기준 레지스터**(base register, relocation register) 

  : 프로세스의 **물리 메모리의 시작 주소**를 저장한다. 

MMU 기법은 프로그램의 주소공간이 물리메모리에 연속적으로 적재됨을 가정한다. 

논리 주소는 기준 레지스터 값으로 부터 얼마나 떨어져 있는지 나타내는 일종의 offset 개념과 같다. 

MMU 기법은 문맥교환으로 CPU에서 수행중인 프로세스가 바뀔 때 마다 기준 레지스터 값을 그 프로세스에 해당되는 값으로 재설정한다. 

* **한계 레지스터** (limit register) 

  : **프로세스가 자신의 주소 공간을 초과하는 메모리 참조를 하는지 확인하는 용도**로 사용한다. 

  MMU 기법으로 주소 변환 시, 해당 프로세스의 주소공간을 초과하는 경우가 발생할 수 있기 때문에 메모리 보안 유지를 위해 쓴다. 

  한계 레지스터 값은 프로세스의 크기와 같다. (== 프로세스의 논리적 주소의 최댓값)

  만약 자신의 주소영역을 초과하면, 트랩(trap)을 발생 시켜 해당 프로세스를 강제종료 시킨다. 

</br></br>

## 3. 메모리 관리에 필요한 개념  

</br>

1)동적 로딩 (dynamic loading)

* 여러 프로그램이 동시에 메모리에 올라가서 수행되는 다중프로그래밍 환경에서 메모리 사용 효율을 높이기 위해 동적 로딩을 사용한다. 

* 동적 로딩은 프로세스 주소공간 전체를 메모리에 올리지 않는다. 실행에 필요한 부분이 실제로 호출될 때 마다 그 부분만 메모리에 적재한다.

* 실제로 프로그램 코드 중 상당 부분은 오류 처리 루틴과 같이 발생 빈도가 낮은 방어용 코드들이다. 

* 동적 로딩은 프로그램 자체에서 구현이 가능하며, OS가 라이브러리를 통해 지원할 수도 있다. 

   

2) 동적 연결 (dynamic linking)

* object file과 library file 연결이 프로그램 실행 시점에 이루어진다. 

* object file : 프로그래머가 작성한 소스코드를 컴파일하여 생성된 목적 파일.

* library file : 이미 컴파일된 라이브러리 파일.

* 정적 연결(static linking)과 대비되어 갖는 장점은 소스 코드 용량을 줄일 수 있다는 점이다. 

* 동적 연결 기법은 OS의 지원이 필요하다. 

  

3) 중첩 

* 프로세스의 주소 공간을 분할하여 **실제 필요한 부분만** 메모리에 적재한다. 
* 동적 로딩과 비슷하다.
* 초창기 시스템에서 물리적 메모리 크기 제약으로 인해 하나의 프로세스 조차 메모리에 전부 올릴 수 없을 때, 프로세스의 주소 공간을 분할하여 당장 필요한 일부만 메모리에 올리는 개념이다. 



4) 스와핑 

* 메모리에 올라온 프로세스의 주소공간 전체를 디스크의 스왑 영역에 일시적으로 내려놓는다. 

  * 디스크 내에 파일 시스템과는 별도로 존재하는 일정 영역이 스왑 영역이다. 

    

* 스와핑 과정 

  * 스와핑의 역할은 메모리에 올라와 있는 **프로세스의 수를 조절**하는 것이다. 
  * swapper라고 불리는 중기스케줄러가 스왑아웃 시킬 프로세스를 선정한다. 
  * 디스크 -> 메모리 로 올리는 작업을 swap in
  * 메모리 -> 디스크 로 내리는 작업 swap out 
  * 스와핑에 소요되는 시간은 디스크 탐색 시간 보다는 실제 데이터를 읽고 쓰는 전송 시간이 대부분을 차지한다.

</br></br>

## 4. 물리적 메모리의 할당 방식   

</br>

1) 연속 할당 방식 

* 고정 분할 

  

* 가변 분할 

2) 불연속 할당 방식 



</br></br>





</br></br>



</br></br>



</br>



</br></br>



</br>



</br>