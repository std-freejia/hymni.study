## 메모리 - 운영체제 

---------

목차 Content

1. 메인 메모리 개요

2. 주소 변환을 수행하는 MMU 기법 (MMU scheme)

3. 메모리 관리에 필요한 개념

   * 동적로딩
   * 동적연결
   * 중첩
   * 스와핑

4. 물리적 메모리의 할당 방식 

   1) 연속할당 방식

   * 고정분할 방식 
* 가변분할 방식
  

2) 불연속 할당방식 

5. 페이징

6. 세그먼테이션

7. 페이지드 세그먼테이션 

</br></br>

-------------

</br>

## 1.메인 메모리 개요 

 컴퓨터는 byte 단위로 메모리 주소를 부여한다. 

32bit 주소체계에서는 2^32 byte 만큼의 서로 다른 주소를 할당할 수 있다. 

우편 주소가 '서울시 양천구 신정동 .. ' 이런 식으로 행정구역을 기준으로 나뉘는 것처럼, 컴퓨터의 메모리 주소도 32bit의 일련의 영역을 나누어 관리한다. 

컴퓨터가 메모리를 어떻게 나누어 관리하는지, 프로그램이 물리적 메모리에 어떻게 올라가서 주소를 할당받는지 살펴보자. 

</br>

* ### 주소 바인딩 

  * CPU는 **논리적 주소가 물리 메모리의 어느 위치에 실제 매핑되는지** 확인하는 것이 주소바인딩이다.

  * 프로그램이 실행을 위해 메모리에 적재되면, 그 프로세스를 위한 독자적인 주소 공간이 생긴다. 이를 논리적 주소(가상 주소)라고 한다. 

    반면, 물리적주소는 물리 메모리에 실제로 존재하는 위치(주소)다. 

  * **CPU는 프로세스 마다의 논리적 주소를 기반으로 명령을 수행한다.** 

     

  </br>

* ### 주소 바인딩의 방식 

  프로그램이 적재되는 '**물리적 메모리의 주소가 결정되는 시점**' 에 따라 3가지 방식이 있다.

  * **컴파일 타임** 바인딩 
    * 물리 메모리 주소가 프로그램을 컴파일할 때 결정되는 주소 바인딩 방식.
    * 물리 메모리 위치 변경을 위해서는 재컴파일 해야하므로 현대의 시분할 컴퓨팅 환경에서 적절치 않아 거의 사용하지 않는다. 
  * **로드 타임** 바인딩 
    * 프로그램 실행이 시작될 때 물리적 메모리 주소가 결정된다. 
    * **로더**(loader)의 책임 하에 메모리 주소가 정해진다. 
  * **실행 타임**(런타임) 바인딩 (execute time binding, run time binding)
    * 실행 중에도 물리 메모리의 주소가 변경될 수 있다. 
    * CPU가 논리 주소를 참조할 때 마다 **주소 매핑 테이블**을 이용해 바인딩을 점검해야 한다.
    * MMU, 기준 레지스터(base register), 한계 레지스터(limit register) 라는 하드웨어적 자원을 기반으로 한다.  

  </br></br>

  

## 2.  주소 변환을 수행하는 MMU scheme 

CPU가 특정 프로세스의 논리 주소를 참조하려고 한다. 

이 때, MMU는 논리 주소에 기준 레지스터 값을 더해서 물리 주소를 얻는다. 

* **기준 레지스터**(base register, relocation register) 

  : 프로세스의 **물리 메모리의 시작 주소**를 저장한다. 

MMU 기법은 프로그램의 주소공간이 물리메모리에 연속적으로 적재됨을 가정한다. 

논리 주소는 기준 레지스터 값으로 부터 얼마나 떨어져 있는지 나타내는 일종의 offset 개념과 같다. 

MMU 기법은 문맥교환으로 CPU에서 수행중인 프로세스가 바뀔 때 마다 기준 레지스터 값을 그 프로세스에 해당되는 값으로 재설정한다. 

* **한계 레지스터** (limit register) 

  : **프로세스가 자신의 주소 공간을 초과하는 메모리 참조를 하는지 확인하는 용도**로 사용한다. 

  MMU 기법으로 주소 변환 시, 해당 프로세스의 주소공간을 초과하는 경우가 발생할 수 있기 때문에 메모리 보안 유지를 위해 쓴다. 

  한계 레지스터 값은 프로세스의 크기와 같다. (== 프로세스의 논리적 주소의 최댓값)

  만약 자신의 주소영역을 초과하면, 트랩(trap)을 발생 시켜 해당 프로세스를 강제종료 시킨다. 

</br></br>

---------------------------



## 3. 메모리 관리에 필요한 개념  

</br>

### 1) 동적 로딩 (dynamic loading)

* 여러 프로그램이 동시에 메모리에 올라가서 수행되는 다중프로그래밍 환경에서 메모리 사용 효율을 높이기 위해 동적 로딩을 사용한다. 
* 동적 로딩은 프로세스 주소공간 전체를 메모리에 올리지 않는다. 실행에 필요한 부분이 실제로 호출될 때 마다 그 부분만 메모리에 적재한다.
* 실제로 프로그램 코드 중 상당 부분은 오류 처리 루틴과 같이 발생 빈도가 낮은 방어용 코드들이다. 
* 동적 로딩은 프로그램 자체에서 구현이 가능하며, OS가 라이브러리를 통해 지원할 수도 있다. 

</br>

### 2) 동적 연결 (dynamic linking)

* object file과 library file 연결이 프로그램 실행 시점에 이루어진다. 

  * object file : 프로그래머가 작성한 소스코드를 컴파일하여 생성된 목적 파일.
  * library file : 이미 컴파일된 라이브러리 파일.

* 동적 연결에서는 라이브러리가 실행 시점에 연결된다. 즉, 실행파일에 라이브러리 코드가 포함 되지 않는다. 

* 실행파일의 라이브러리 호출 부분에 해당 라이브러리의 위치를 찾기 위한  스텁(stub)이라는 작은 코드를 둔다. 

* 정적 연결(static linking)과 대비되어 갖는 장점

  * 소스 코드 용량을 줄일 수 있다는 점이다. 
  * 다수의 프로그램이 공통으로 사용하는 라이브러리를 메모리에 한 번만 적재하니까 메모리 사용효율이 높다.


</br>

### 3) 중첩 (overlays)

* 프로세스의 주소 공간을 분할하여 **실제 필요한 부분만** 메모리에 적재한다. 
* 동적 로딩과 비슷하다.
* 초창기 시스템에서 물리적 메모리 크기 제약으로 인해 하나의 프로세스 조차 메모리에 전부 올릴 수 없을 때, 프로세스의 주소 공간을 분할하여 당장 필요한 일부만 메모리에 올리는 개념이다. 

</br>

### 4) 스와핑 (swapping)

* 메모리에 올라온 프로세스의 주소공간 전체를 디스크의 스왑 영역(swap area, backing store)에 일시적으로 내려놓는다. 

  * 디스크 내에 파일 시스템과는 별도로 존재하는 일정 영역이 스왑 영역이다. 

    

* 스와핑 과정 

  * 스와핑의 역할은 메모리에 올라와 있는 **프로세스의 수를 조절**하는 것이다. 
  * 스와퍼(swapper)라고 불리는 중기스케줄러(medium-term scheduler)가 스왑아웃 시킬 프로세스를 선정한다. 
  * 디스크 -> 메모리 로 올리는 작업을 swap in
  * 메모리 -> 디스크 로 내리는 작업 swap out 
  * 스와핑에 소요되는 시간은 디스크 탐색 시간(seek time)보다는 실제 데이터를 읽고 쓰는 전송 시간(transfer time)이 대부분을 차지한다.

</br></br>

-------------------



## 4. 물리적 메모리의 할당 방식   

</br>

물리적 메모리는 운영체제 상주 영역과 사용자 프로세스 영역으로 나뉜다. 

* 운영체제 상주 영역: 물리적 메모리의 낮은 주소에 있고 인터럽트 벡터, 커널이 위치한다.  
* 사용자 프로세스 영역 : 물리적 메모리의 높은 주소 영역을 사용한다. 

여기서 사용자 프로세스 영역의 관리 방법을 알아보자. 

프로세스를 메모리에 연속적으로 올리느냐, 불연속적으로 올리느냐로 일단 크게 나뉜다. 

</br>

### 1) 연속 할당 방식 (Contiguous allocation)

* 연속 할당은 각각의 프로세스의 주소공간을 물리적 메모리의 연속적인 공간에 올린다. 

* 물리적 메모리를 다수의 분할로 나누어 하나의 분할에 하나의 프로세스를 적재한다. 

* 분할을 관리하는 방식에 따라 고정분할, 가변분할로 나뉜다. 

  </br>

  * ### **고정 분할** (Fixed partition)

    * 고정 크기의 분할로 **물리메모리를 미리 나누고**, 각 분할에 하나의 프로세스를 적재해 실행한다. 

    * 즉, 동시에 메모리에 올릴 프로세스의 수가 고정되어 있다. 

    * 수행가능한 프로그램의 최대 크기가 제한된다. 

    * #### **외부조각**(External fragmentation) 

      * **프로그램 크기 >** 분할 크기.  (프로그램이 못 올라간다)

    * **내부조각**(Internal fragmentation)

      * 프로그램 크기 **< 분할 크기**  ( 분할 내부에 공간이 남는다) 

  </br>

  * ### **가변 분할** (Variable partition)

    * 메모리에 적재되는 프로그램의 크기에 따라 분할의 크기, 개수가 동적으로 변한다. 

    * 프로그램 크기를 고려햐여 메모리를 할당하고 이를 관리할 방법이 필요하다. 

    * 분할 크기를 프로그램 크기보다 일부러 크게 잡지 않으니까, 내부조각 발생은 안한다. 

    * 프로그램이 못올라가는 외부조각 발생 가능성은 있다. 

      </br>

      * #### **동적 메모리 할당 문제** (Dynamic Storage-Allocation Problem)

        * 최초 배치(First-fit) : 순차 탐색하여 가용 공간을 선택

        * 최적 배치(Best-fit) : 전체 탐색하여 가장 작은 가용공간을 선택 

        * 최악 배치 : best fit 반대 

          </br>

      * #### **압축** (Compaction) : 외부조각 해결법

        * 사용중인 메모리영역을 한쪽으로 몰아 하나의 큰 가용공간을 만든다. 비용 많이 든다.

          </br>

### 2) 불연속 할당 방식 (Noncontiguous allocation)

* 하나의 프로세스를 물리적 메모리의 여러 영역에 분산하여 적재한다. 
  * 페이징  : 동일한 크기로 나누기 
  * 세그먼테이션 : 의미 단위로 나누기 
  * 페이지드 세그먼테이션 : 의미 단위로 나누되, 다시 동일한 페이지로 나누기 

</br></br>

-------------------------



## 5.  페이징

</br>

프로세스의 주소 공간을 동일한 크기의 페이지 단위로 나뉜다. 

물리적 메모리의 서로 다른 위치에 페이지들을 저장한다. 

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F3IvrI%2Fbtqvib0cE9C%2FdyicpUxZKT1jVyW3OqGkO1%2Fimg.png)

물리적 메모리를 페이지와 동일한 크기의 frame 으로 미리 나누어 둔다. 

</br>

1) 주소 변환 절차 (Address Translation Architecture)

하나의 프로세스라도 페이지 단위로 물리적 메모리에 올리는 위치가 다르다.

그래서 논리적 주소를 물리적 주소로 변환하는 작업이 필요하다. 

</br>

2) 페이지 테이블의 구현 



</br>

3) 계층적 페이징 



</br>

4) 역페이지 테이블 



</br>

5) 공유 페이지



</br></br>

--------------------------

## 6. 세그먼테이션

</br>

1) 주소 변환 기법



</br>

2) 공유 세그먼트 

 

</br></br>

----------------

## 7. 페이지드 세그먼테이션

</br>



</br></br>



</br>



</br>